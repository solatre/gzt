<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Golden Christmas Gesture App</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050a05; font-family: 'Segoe UI', sans-serif; }
        
        /* 顶部导航栏 */
        header {
            position: fixed;
            top: 0; width: 100%; height: 60px;
            background: rgba(10, 30, 10, 0.8);
            border-bottom: 2px solid #d4af37; /* 金属金 */
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 20px; z-index: 100; color: #d4af37;
        }

        .controls { display: flex; gap: 15px; align-items: center; margin-right: 40px;}
        
        button {
            background: #a32638; /* 圣诞红 */
            color: #d4af37; border: 1px solid #d4af37;
            padding: 8px 15px; cursor: pointer; border-radius: 4px;
            font-weight: bold; transition: 0.3s;
        }
        button:hover { background: #d4af37; color: #a32638; }

        #upload-label { font-size: 12px; border: 1px dashed #d4af37; padding: 5px; cursor: pointer; }

        /* 右下角视频 */
        #video-container {
            position: fixed; bottom: 20px; right: 20px;
            width: 240px; height: 180px;
            border: 2px solid #d4af37; border-radius: 10px;
            overflow: hidden; box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
            transform: scaleX(-1);
        }
        #webcam { width: 100%; height: 100%; object-fit: cover; }
        canvas.output_canvas { position: absolute; left: 0; top: 0; width: 100%; height: 100%; }

        #status-indicator {
            position: fixed; bottom: 210px; right: 25px;
            color: #d4af37; font-weight: bold; text-shadow: 0 0 5px #000;
        }
    </style>
</head>
<body>

<header>
    <div style="font-size: 24px; letter-spacing: 2px;">GOLDEN XMAS GESTURE</div>
    <div class="controls">
        <label id="upload-label">上传照片 <input type="file" id="image-upload" hidden multiple accept="image/*"></label>
        <button id="start-btn">开启系统</button>
    </div>
</header>

<div id="status-indicator">系统准备就绪</div>

<div id="video-container">
    <video id="webcam"></video>
    <canvas class="output_canvas"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/** 1. 初始化 Three.js 环境 **/
let scene, camera, renderer, composer, particles = [];
const PARTICLE_COUNT = 150;
let currentState = 'CLOSE'; // CLOSE, SCATTER, ZOOM

function initThree() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050a05, 0.02);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 15;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // 辉光效果
    const renderScene = new THREE.RenderPass(scene, camera);
    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.2;
    bloomPass.strength = 1.2;
    bloomPass.radius = 0.5;

    composer = new THREE.EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(10, 10, 10);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x204020));

    createParticles();
    animate();
}

/** 2. 创建粒子圣诞树 **/
function createParticles() {
    const goldMat = new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 0.9, roughness: 0.1 });
    const greenMat = new THREE.MeshStandardMaterial({ color: 0x1a3a1a, metalness: 0.3, roughness: 0.8 }); // 哑光绿
    const redMat = new THREE.MeshStandardMaterial({ color: 0xa32638, emissive: 0x300000 });

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        let geometry;
        const rand = Math.random();
        if (rand < 0.4) geometry = new THREE.SphereGeometry(0.15, 16, 16);
        else if (rand < 0.7) geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        else geometry = new THREE.PlaneGeometry(0.6, 0.8);

        const material = (i % 3 === 0) ? goldMat : (i % 3 === 1 ? greenMat : redMat);
        const mesh = new THREE.Mesh(geometry, material.clone());
        
        // 初始圣诞树圆锥位置逻辑
        const ratio = i / PARTICLE_COUNT;
        const angle = ratio * Math.PI * 20;
        const radius = (1 - ratio) * 5;
        mesh.userData.closePos = new THREE.Vector3(
            Math.cos(angle) * radius,
            ratio * 12 - 6,
            Math.sin(angle) * radius
        );
        
        // 随机散开位置
        mesh.userData.scatterPos = new THREE.Vector3(
            (Math.random() - 0.5) * 30,
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20
        );

        mesh.position.copy(mesh.userData.closePos);
        scene.add(mesh);
        particles.push(mesh);
    }
}

/** 3. 状态切换动画 **/
function transitionTo(state) {
    if (currentState === state) return;
    currentState = state;
    document.getElementById('status-indicator').innerText = "当前状态: " + state;

    particles.forEach((mesh, i) => {
        const targetPos = (state === 'CLOSE') ? mesh.userData.closePos : mesh.userData.scatterPos;
        
        new TWEEN.Tween(mesh.position)
            .to({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, 1500)
            .easing(TWEEN.Easing.Quadratic.Out)
            .start();

        new TWEEN.Tween(mesh.rotation)
            .to({ x: Math.random() * 6, y: Math.random() * 6 }, 1500)
            .start();
    });

    if (state === 'ZOOM') {
        const target = particles[Math.floor(Math.random() * particles.length)];
        new TWEEN.Tween(target.position).to({ x: 0, y: 0, z: 10 }, 1000).start();
        new TWEEN.Tween(target.scale).to({ x: 5, y: 5, z: 5 }, 1000).start();
    } else {
        particles.forEach(p => new TWEEN.Tween(p.scale).to({ x: 1, y: 1, z: 1 }, 500).start());
    }
}

/** 4. 手势识别逻辑 **/
const videoElement = document.getElementById('webcam');
const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

hands.onResults((results) => {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        results.multiHandLandmarks.forEach((landmarks, index) => {
            const label = results.multiHandedness[index].label; // Left or Right
            
            // 判断是否握拳 (指尖到掌心的距离平均值)
            const palm = landmarks[0];
            const tips = [landmarks[8], landmarks[12], landmarks[16], landmarks[20]];
            let avgDist = 0;
            tips.forEach(t => {
                avgDist += Math.hypot(t.x - palm.x, t.y - palm.y);
            });

            if (label === 'Right') { // MediaPipe 镜像后，物理左手通常识别为 Right
                if (avgDist < 0.2) transitionTo('CLOSE');
                else transitionTo('SCATTER');
            } else { // 物理右手
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                if (pinchDist < 0.05) transitionTo('ZOOM');
            }
        });
    }
});

/** 5. 上传与启动 **/
document.getElementById('image-upload').addEventListener('change', (e) => {
    const files = e.target.files;
    for (let i = 0; i < files.length; i++) {
        const reader = new FileReader();
        reader.onload = (event) => {
            const texture = new THREE.TextureLoader().load(event.target.result);
            const p = particles[Math.floor(Math.random() * particles.length)];
            p.material = new THREE.MeshStandardMaterial({ map: texture });
        };
        reader.readAsDataURL(files[i]);
    }
});

document.getElementById('start-btn').addEventListener('click', () => {
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });
    cameraUtils.start();
    initThree();
    document.getElementById('start-btn').disabled = true;
});

function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();
    scene.rotation.y += 0.002;
    composer.render();
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
