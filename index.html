<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Christmas | Final Ultimate Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; z-index: 1; }
        
        /* UI */
        #ui-layer {
            position: absolute; bottom: 30px; left: 30px; z-index: 10000;
            display: flex; gap: 20px; align-items: center;
            pointer-events: none;
        }
        
        .glass-btn {
            background: rgba(10, 20, 40, 0.8); 
            border: 1px solid rgba(0, 85, 255, 0.6);
            color: #00ffff; 
            padding: 12px 30px; 
            border-radius: 30px; 
            cursor: pointer;
            font-family: monospace; 
            font-size: 14px; 
            text-transform: uppercase; 
            letter-spacing: 2px;
            backdrop-filter: blur(10px); 
            box-shadow: 0 0 20px rgba(0, 85, 255, 0.3);
            transition: all 0.2s;
            pointer-events: auto;
            user-select: none;
            display: inline-block;
        }
        .glass-btn:active { transform: scale(0.95); background: rgba(0, 85, 255, 0.3); }
        .glass-btn:hover { box-shadow: 0 0 40px rgba(0, 85, 255, 0.6); color: #fff; }

        #file-input { display: none; }

        /* Hand Camera */
        #hand-interface {
            position: absolute; bottom: 30px; right: 30px; width: 220px; height: 165px;
            border-radius: 12px; overflow: hidden;
            border: 1px solid rgba(0, 85, 255, 0.3); background: rgba(0,0,0,0.8); z-index: 10000;
            pointer-events: auto;
        }
        #webcam, #output_canvas { position: absolute; width: 100%; height: 100%; transform: scaleX(-1); }
        #webcam { opacity: 0.2; object-fit: cover; }

        #status-text {
            position: absolute; top: 30px; width: 100%; text-align: center;
            color: rgba(100, 200, 255, 0.9); font-family: monospace; letter-spacing: 3px;
            font-size: 14px; pointer-events: none; z-index: 10; text-shadow: 0 0 10px #000;
        }

        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 20000; display: flex; justify-content: center; align-items: center;
            color: #0055ff; font-family: monospace; letter-spacing: 5px; font-size: 14px;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="loading">GENERATING COSMOS...</div>
    <div id="status-text">SYSTEM ONLINE</div>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <label class="glass-btn">
            ＋ ADD MEMORIES
            <input type="file" id="file-input" accept="image/*" multiple>
        </label>
    </div>

    <div id="hand-interface">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <!-- SHADER: Particle Brightness Boost -->
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute float opacityAttr;
        attribute float twinkleSpeed;
        attribute float twinkleOffset;
        attribute vec3 customColor;
        
        varying vec3 vColor;
        varying float vAlpha;
        
        uniform float uTime;
        uniform float uScale;

        void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            float blink = sin(uTime * twinkleSpeed + twinkleOffset);
            float brightness = pow(0.5 * blink + 0.5, 3.0); 
            float sizeVar = 1.0 + 0.5 * brightness;
            gl_PointSize = size * sizeVar * uScale * (500.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
            vAlpha = opacityAttr * (0.6 + 0.4 * brightness);
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform sampler2D pointTexture;
        varying vec3 vColor;
        varying float vAlpha;

        void main() {
            vec4 texColor = texture2D(pointTexture, gl_PointCoord);
            if (texColor.a < 0.1) discard;
            gl_FragColor = vec4(vColor * 2.0, vAlpha * texColor.a);
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        const BLOOM_LAYER = 1; 

        // --- UPLOAD LOGIC ---
        const fileInput = document.getElementById('file-input');
        fileInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files.length > 0) {
                const count = e.target.files.length;
                document.getElementById('status-text').innerText = `PROCESSING ${count} PHOTOS...`;
                Array.from(e.target.files).forEach(f => {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        const img = new Image();
                        img.onload = () => {
                            const tex = new THREE.Texture(img);
                            tex.needsUpdate = true;
                            tex.colorSpace = THREE.SRGBColorSpace;
                            addPhoto(tex);
                        }; img.src = evt.target.result;
                    }; reader.readAsDataURL(f);
                });
            }
        });

        // --- TEXT GENERATION ---
        function generateTextCoordinates(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 600; canvas.height = 150;
            ctx.font = '900 80px "Times New Roman", serif'; 
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width/2, canvas.height/2);
            
            const imageData = ctx.getImageData(0,0, canvas.width, canvas.height).data;
            const coords = [];
            for(let y=0; y<canvas.height; y+=2) { 
                for(let x=0; x<canvas.width; x+=2) {
                    if(imageData[(y*canvas.width + x)*4 + 3] > 128) {
                        coords.push({
                            x: (x - canvas.width/2) * 0.1,
                            y: -(y - canvas.height/2) * 0.1 
                        });
                    }
                }
            }
            return coords;
        }
        const textCoords = generateTextCoordinates("Merry Christmas");

        // --- CONFIG ---
        const CONFIG = {
            count: 45000, 
            trunkCount: 4000,
            textCount: textCoords.length,
            bgStarCount: 8000,
            treeHeight: 85,
            treeRadius: 35,
            galaxyRadius: 300, 
            floorRadius: 200, 
            colors: {
                cyan: new THREE.Color('#00ffff').multiplyScalar(2.0), 
                blue: new THREE.Color('#0055ff').multiplyScalar(2.0),
                purple: new THREE.Color('#aa00ff').multiplyScalar(2), 
                gold: new THREE.Color('#ffcc00').multiplyScalar(2), 
                white: new THREE.Color('#ffffff').multiplyScalar(2)
            }
        };

        const state = {
            mode: 'TREE',
            targetMode: 'TREE', 
            activePhoto: null,
            focusTargetPos: new THREE.Vector3(),
            focusTargetLook: new THREE.Vector3(),
            isPointing: false,
            handHistory: [],
            rotVelocity: 0,
            lastSwitchTime: 0,
            
            animPhase: 'IDLE',
            animTimer: 0,
            lerpSpeed: 0.05
        };

        const photos = [];
        const photoGroup = new THREE.Group();
        const particleData = []; 

        // --- SCENE ---
        const container = document.getElementById('canvas-container');
        const statusText = document.getElementById('status-text');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.set(0, 40, 110);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0; 
        
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.enableRotate = true; controls.autoRotate = true; controls.autoRotateSpeed = 0.5;

        // --- SELECTIVE BLOOM SETUP ---
        const renderScene = new RenderPass(scene, camera);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2; 
        bloomPass.strength = 0.7;
        bloomPass.radius = 0.8;

        const bloomComposer = new EffectComposer(renderer);
        bloomComposer.renderToScreen = false;
        bloomComposer.addPass(renderScene);
        bloomComposer.addPass(bloomPass);

        const mixShader = {
            uniforms: {
                baseTexture: { value: null },
                bloomTexture: { value: null }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform sampler2D baseTexture;
                uniform sampler2D bloomTexture;
                varying vec2 vUv;
                void main() {
                    gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );
                }
            `
        };

        const mixPass = new ShaderPass(
            new THREE.ShaderMaterial({
                uniforms: mixShader.uniforms,
                vertexShader: mixShader.vertexShader,
                fragmentShader: mixShader.fragmentShader,
                defines: {}
            }), "baseTexture"
        );
        mixPass.needsSwap = true;

        const finalComposer = new EffectComposer(renderer);
        finalComposer.addPass(renderScene);
        finalComposer.addPass(mixPass);
        finalComposer.addPass(new OutputPass());

        const darkMaterial = new THREE.MeshBasicMaterial({ color: 'black' });
        const materials = {};
        const bloomLayer = new THREE.Layers();
        bloomLayer.set(BLOOM_LAYER);

        function darkenNonBloomed(obj) {
            if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
                materials[obj.uuid] = obj.material;
                obj.material = darkMaterial;
            }
        }
        function restoreMaterial(obj) {
            if (materials[obj.uuid]) {
                obj.material = materials[obj.uuid];
                delete materials[obj.uuid];
            }
        }

        // --- ASSETS ---
        function getTexture() {
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0, 16,16,16);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.4, 'rgba(255,255,255,0.2)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g; ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(c);
        }

        // --- GEOMETRY ---
        const mat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff,
            transparent: true,    
            opacity: 0.15,         
            blending: THREE.AdditiveBlending, 
            depthWrite: false     
        });

        const sphereGeo = new THREE.IcosahedronGeometry(0.35, 1);
        const boxGeo = new THREE.BoxGeometry(0.45, 0.45, 0.45);
        const tetraGeo = new THREE.TetrahedronGeometry(0.5);

        const countSphere = Math.floor(CONFIG.count * 0.5);
        const countBox = Math.floor(CONFIG.count * 0.3);
        const countTetra = CONFIG.count - countSphere - countBox;

        const meshSphere = new THREE.InstancedMesh(sphereGeo, mat.clone(), countSphere);
        const meshBox = new THREE.InstancedMesh(boxGeo, mat.clone(), countBox);
        const meshTetra = new THREE.InstancedMesh(tetraGeo, mat.clone(), countTetra);

        meshSphere.layers.enable(BLOOM_LAYER);
        meshBox.layers.enable(BLOOM_LAYER);
        meshTetra.layers.enable(BLOOM_LAYER);

        scene.add(meshSphere); scene.add(meshBox); scene.add(meshTetra);
        const dummy = new THREE.Object3D();

        // --- STAR ---
        function createStar() {
            const shape = new THREE.Shape();
            const pts = 5; for(let i=0; i<pts*2; i++){ const r = (i%2===0)?4.0:1.8; const a = (i/pts)*Math.PI; shape.lineTo(Math.sin(a)*r, Math.cos(a)*r); }
            const g = new THREE.ExtrudeGeometry(shape, {depth:1.5, bevelEnabled:true, bevelThickness:0.4});
            g.center();
            
            const starColor = new THREE.Color(0xffaa00); 
            starColor.multiplyScalar(2.0); 
            
            const m = new THREE.MeshBasicMaterial({ color: starColor }); 
            const mesh = new THREE.Mesh(g, m);
            mesh.add(new THREE.PointLight(0xffaa00, 10, 100));
            mesh.layers.enable(BLOOM_LAYER);
            return mesh;
        }
        const star = createStar(); scene.add(star);

        // --- BG STARS ---
        function createBgStars() {
            const geo = new THREE.BufferGeometry();
            const pos = []; const sizes = []; const shifts = [];
            for(let i=0; i<CONFIG.bgStarCount; i++) {
                const r = 800 + Math.random() * 1700; 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                pos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                sizes.push(Math.random() * 5.0 + 3.0); 
                shifts.push(Math.random() * 100.0);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute('shift', new THREE.Float32BufferAttribute(shifts, 1));

            const m = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, color: { value: new THREE.Color(0xffffff) } },
                vertexShader: `
                    attribute float size; attribute float shift; uniform float uTime;
                    void main() {
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        float shine = sin(uTime * 1.0 + shift); 
                        float scale = 0.8 + 0.5 * shine; 
                        gl_PointSize = size * scale * (800.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    void main() {
                        float d = distance(gl_PointCoord, vec2(0.5));
                        if(d > 0.5) discard;
                        float alpha = 1.0 - smoothstep(0.1, 0.5, d);
                        gl_FragColor = vec4(color, alpha); 
                    }
                `,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            const bg = new THREE.Points(geo, m);
            scene.add(bg);
            return m;
        }
        const bgStarMat = createBgStars();

        // --- HEART ALGORITHM ---
        function getRandomHeartPoint() {
            let x, y, z;
            while (true) {
                x = Math.random() * 3 - 1.5;
                y = Math.random() * 3 - 1.5;
                z = Math.random() * 3 - 1.5;
                const x2 = x * x; const y2 = y * y; const z2 = z * z;
                const a = x2 + 2.25 * z2 + y2 - 1;
                const b = x2 * y2 * y + 0.1125 * z2 * y2 * y;
                if (a * a * a - b < 0) {
                    const scale = 40; 
                    return new THREE.Vector3(x * scale, y * scale + 45, z * scale); 
                }
            }
        }

        // --- PARTICLES INIT ---
        for(let i=0; i<CONFIG.count; i++) {
            const isText = i < CONFIG.textCount;
            const isTrunk = !isText && i < (CONFIG.textCount + CONFIG.trunkCount);
            
            const p = {
                currentPos: new THREE.Vector3(),
                tTree: new THREE.Vector3(), tScatter: new THREE.Vector3(), tExplode: new THREE.Vector3(), tHeart: new THREE.Vector3(),
                color: new THREE.Color(), speed: 1.0 + Math.random() * 5.0, offset: Math.random() * 100.0,
                baseScale: 0.5 + Math.random() * 0.9, meshIndex: 0, internalIndex: 0,
                isFloor: false, floorRadius: 0, floorAngle: 0
            };

            if (i < countSphere) { p.meshIndex = 0; p.internalIndex = i; }
            else if (i < countSphere + countBox) { p.meshIndex = 1; p.internalIndex = i - countSphere; }
            else { p.meshIndex = 2; p.internalIndex = i - countSphere - countBox; }

            p.tHeart.copy(getRandomHeartPoint());

            if (isText) {
                const coord = textCoords[i];
                p.tScatter.set(coord.x, coord.y + 12, 0); 
                p.isFloor = true;
                const r = Math.random() * CONFIG.floorRadius; const a = Math.random() * Math.PI * 2;
                p.floorRadius = r; p.floorAngle = a;
                p.tTree.set(r * Math.cos(a), 0, r * Math.sin(a));
                p.color.set(CONFIG.colors.gold);

            } else if (isTrunk) {
                const h = ((i - CONFIG.textCount)/CONFIG.trunkCount) * (CONFIG.treeHeight * 0.9);
                const r = Math.random() * 2.0; const a = Math.random() * Math.PI * 2;
                p.tTree.set(r*Math.cos(a), h, r*Math.sin(a));
                p.color.set(CONFIG.colors.gold).lerp(new THREE.Color('#331100'), Math.random()*0.5);
                const gr = Math.random() * 15; const ga = Math.random() * Math.PI * 2;
                p.tScatter.set(gr*Math.cos(ga), (Math.random()-0.5)*8, gr*Math.sin(ga));

            } else {
                const typeRand = Math.random();
                if (typeRand > 0.3) {
                    const h = Math.random() * CONFIG.treeHeight;
                    const layerMod = 1.0 + 0.3 * Math.sin(h * 0.8); 
                    const rBase = CONFIG.treeRadius * (1 - h/CONFIG.treeHeight);
                    const rMax = rBase * layerMod;
                    const r = rMax * (0.4 + 0.6 * Math.sqrt(Math.random()));
                    const a = h * 0.5 + Math.random() * Math.PI * 2;
                    p.tTree.set(r*Math.cos(a), h, r*Math.sin(a));
                    if (Math.random() > 0.98) p.color.set(CONFIG.colors.gold);
                    else p.color.set(CONFIG.colors.cyan).lerp(CONFIG.colors.purple, Math.random());

                } else {
                    p.isFloor = true;
                    const r = 5 + Math.random() * CONFIG.floorRadius; 
                    const a = Math.random() * Math.PI * 2;
                    p.floorRadius = r; p.floorAngle = a;
                    p.tTree.set(r * Math.cos(a), 0, r * Math.sin(a));
                    p.color.set(CONFIG.colors.blue).lerp(CONFIG.colors.purple, Math.random());
                }

                const minR = 20; const maxR = CONFIG.galaxyRadius;
                const t = Math.pow(Math.random(), 1.2);
                const gr = minR + t * (maxR - minR);
                const arms = 3; const spin = 6.0;
                const armOffset = Math.floor(Math.random()*arms)*(Math.PI*2/arms);
                const spiralAngle = (gr/maxR)*spin*Math.PI;
                const spreadWidth = 1.0 + (gr/maxR) * 4.0; 
                const randomOffset = (Math.random()-0.5) * spreadWidth;
                const ga = armOffset + spiralAngle + randomOffset;
                const dip = -20 * Math.exp(-(gr-minR)/30);
                const gy = dip + (Math.random()-0.5)*(5 + (gr/maxR)*15);
                p.tScatter.set(gr*Math.cos(ga), gy, gr*Math.sin(ga));

                const noise = Math.random();
                if (noise > 0.97) p.color.set(CONFIG.colors.white);
                else if (Math.random() > 0.5) p.color.set(CONFIG.colors.cyan);
                else p.color.set(CONFIG.colors.blue).lerp(CONFIG.colors.purple, Math.random()*0.5);
            }
            p.currentPos.copy(p.tTree);
            particleData.push(p);
        }

        particleData.forEach(p => {
            if(p.meshIndex===0) meshSphere.setColorAt(p.internalIndex, p.color);
            else if(p.meshIndex===1) meshBox.setColorAt(p.internalIndex, p.color);
            else meshTetra.setColorAt(p.internalIndex, p.color);
        });
        meshSphere.instanceColor.needsUpdate = true;
        meshBox.instanceColor.needsUpdate = true;
        meshTetra.instanceColor.needsUpdate = true;

        // --- PHOTO SYSTEM ---
        function addPhoto(tex) {
            const aspect = tex.image.width / tex.image.height;
            const h = 7; const w = h * aspect; 
            
            const frameH = h + 1.0; 
            const frameW = w + 0.4;
            const frameGeo = new THREE.PlaneGeometry(frameW, frameH);
            const frameMat = new THREE.MeshBasicMaterial({ color: 0xeeeeee, side: THREE.DoubleSide }); 
            const frameMesh = new THREE.Mesh(frameGeo, frameMat);

            const photoGeo = new THREE.PlaneGeometry(w, h);
            const photoMat = new THREE.MeshBasicMaterial({ 
                map: tex, side: THREE.DoubleSide, transparent: true, opacity: 1.0, 
                color: 0xffffff, depthTest: true
            });
            const photoMesh = new THREE.Mesh(photoGeo, photoMat);
            photoMesh.position.set(0, 0.3, 0.02);
            frameMesh.add(photoMesh);
            
            // 修复：计算均匀的树形坐标
            const th = Math.random() * CONFIG.treeHeight * 0.8 + 10;
            const layerMod = 1.0 + 0.3 * Math.sin(th * 0.8);
            const tr = CONFIG.treeRadius * (1 - th/CONFIG.treeHeight) * layerMod + 5.0; 
            const ta = Math.random() * Math.PI * 2;
            const treePos = new THREE.Vector3(tr*Math.cos(ta), th, tr*Math.sin(ta));
            const treeRot = new THREE.Euler(0, -ta + Math.PI/2, 0);

            // 修复：计算爆炸目标点 (距离足够远)
            const exR = 1000 + Math.random() * 500; 
            const exPhi = Math.acos(2 * Math.random() - 1);
            const exTheta = Math.random() * Math.PI * 2;
            const explodePos = new THREE.Vector3(
                exR * Math.sin(exPhi) * Math.cos(exTheta),
                exR * Math.sin(exPhi) * Math.sin(exTheta),
                exR * Math.cos(exPhi)
            );

            const heartPos = getRandomHeartPoint();

            frameMesh.userData = {
                treePos: treePos,
                treeRot: treeRot,
                scatterRadius: 50 + Math.random() * 50, 
                scatterAngle: Math.random() * Math.PI * 2, 
                scatterY: (Math.random()-0.5)*10,
                heartPos: heartPos, 
                explodePos: explodePos,
                selfRotSpeed: (Math.random()-0.5) * 0.02
            };
            photoGroup.add(frameMesh); 
            photos.push(frameMesh);
            
            statusText.innerText = `MEMORY UPLOADED: ${photos.length} TOTAL`;
            setTimeout(() => { if(!state.isPointing) statusText.innerText = "SYSTEM ONLINE"; }, 3000);
        }
        scene.add(photoGroup);

        // --- HAND TRACKING ---
        let handLandmarker;
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('output_canvas');
        const ctx = canvas.getContext('2d');

        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            document.getElementById('loading').style.display = 'none';
            navigator.mediaDevices.getUserMedia({video: true}).then(s => {
                video.srcObject = s; video.addEventListener('loadeddata', predict);
            });
        }

        let lastTime = -1;
        function predict() {
            if(video.currentTime !== lastTime) {
                lastTime = video.currentTime;
                const res = handLandmarker.detectForVideo(video, performance.now());
                ctx.clearRect(0,0,canvas.width,canvas.height);
                if(res.landmarks.length > 0) {
                    const lm = res.landmarks[0];
                    drawHand(lm);
                    analyze(lm);
                } else {
                    state.isPointing = false; state.handHistory = [];
                    if(state.mode === 'SCATTER' && !state.activePhoto) statusText.innerText = "GALAXY MODE: WAVE FINGERS TO SPIN";
                }
            }
            requestAnimationFrame(predict);
        }

        function drawHand(lm) {
            ctx.strokeStyle = "#00ffff"; ctx.lineWidth = 2;
            const p = i => ({x: lm[i].x*canvas.width, y: lm[i].y*canvas.height});
            [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]].forEach(l => { ctx.beginPath(); ctx.moveTo(p(l[0]).x, p(l[0]).y); ctx.lineTo(p(l[1]).x, p(l[1]).y); ctx.stroke(); });
            if(state.isPointing) { ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(p(8).x, p(8).y, 8,0,6.28); ctx.fill(); }
        }

        function analyze(lm) {
            const dist = (a,b) => Math.hypot(lm[a].x-lm[b].x, lm[a].y-lm[b].y);
            const wrist=0; const idxTip=8; const idxPip=6; 
            const midTip=12; const midPip=10; const rngTip=16; const rngPip=14;

            const isIdxExt = dist(wrist, idxTip) > dist(wrist, idxPip) * 1.1;
            const isOthersCurl = (dist(wrist, midTip) < dist(wrist, midPip));
            state.isPointing = isIdxExt && isOthersCurl;

            const pinchDist = dist(4, 8); 
            const tips = [8,12,16,20];
            const avgTipDist = tips.reduce((s,t)=>s+dist(0,t),0)/4; 

            // A. Heart (Pinch)
            if (pinchDist < 0.05) {
                if (state.targetMode !== 'HEART') {
                    state.targetMode = 'HEART';
                    state.activePhoto = null;
                }
                statusText.innerText = "HEART MODE";
                return;
            }

            // B. Pointing (View Photo) - 增加误触保护
            if (state.isPointing && state.mode !== 'TREE' && avgTipDist < 0.35) {
                statusText.innerText = "POINTING: VIEW PHOTO (SWIPE LEFT NEXT)";
                if(!state.activePhoto) findNearestPhoto(); 
                
                const x = lm[idxTip].x;
                state.handHistory.push({x, t: Date.now()});
                if(state.handHistory.length > 5) state.handHistory.shift();
                if(state.handHistory.length >= 2) {
                    const dx = state.handHistory[state.handHistory.length-1].x - state.handHistory[0].x;
                    if (Math.abs(dx) > 0.1 && Date.now() - state.lastSwitchTime > 800) {
                        state.lastSwitchTime = Date.now(); cycleRandomPhoto();
                    }
                }
                return; 
            }

            // C. Tree (Fist)
            if (avgTipDist < 0.25) {
                if (state.targetMode !== 'TREE') {
                    state.targetMode = 'TREE';
                    state.activePhoto = null;
                }
                statusText.innerText = "TREE MODE (OPEN HAND TO SCATTER)";
            }
            
            // D. Galaxy (Open Hand)
            else if (avgTipDist > 0.45) {
                if (state.targetMode !== 'SCATTER') {
                    state.targetMode = 'SCATTER';
                }
                
                if (state.activePhoto) {
                    // Viewing photo
                } else {
                    statusText.innerText = "GALAXY MODE: WAVE FINGERS TO SPIN";
                    const avgTipX = (lm[8].x + lm[12].x + lm[16].x + lm[20].x) / 4;
                    state.handHistory.push({x: avgTipX, t: Date.now()});
                    if(state.handHistory.length > 5) state.handHistory.shift();
                    if(state.handHistory.length >= 2) {
                        const last = state.handHistory[state.handHistory.length-1];
                        const first = state.handHistory[0];
                        const dx = last.x - first.x;
                        if (Math.abs(dx) > 0.01) state.rotVelocity += dx * 20.0; 
                    }
                }
            }
        }

        function findNearestPhoto() {
            if(photos.length===0) return;
            let minD = Infinity; let nearest = null;
            photos.forEach(p => { const d = camera.position.distanceTo(p.position); if(d<minD) { minD=d; nearest=p; } });
            if(nearest) state.activePhoto = nearest;
        }
        function cycleRandomPhoto() {
            if(photos.length===0) return;
            let next; do{next=photos[Math.floor(Math.random()*photos.length)]}while(next===state.activePhoto && photos.length>1);
            state.activePhoto = next;
        }

        // --- LOOP ---
        const clock = new THREE.Clock();
        const vTmp = new THREE.Vector3();
        const hudPosition = new THREE.Vector3(0, 0, -30); 

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            if (bgStarMat) bgStarMat.uniforms.uTime.value = time;

            if (state.mode !== state.targetMode) {
                state.mode = state.targetMode;
                state.animPhase = 'EXPLODE';
                state.animTimer = 0;
                state.lerpSpeed = 0;
                for(let i=0; i<CONFIG.count; i++) {
                    const p = particleData[i];
                    const exR = 200 + Math.random() * 400; 
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    p.tExplode.set(exR * Math.sin(phi) * Math.cos(theta), exR * Math.sin(phi) * Math.sin(theta), exR * Math.cos(phi));
                }
            }

            if (state.animPhase === 'EXPLODE') {
                state.animTimer += dt;
                if (state.animTimer > 0.4) {
                    state.animPhase = 'CONVERGE';
                    state.lerpSpeed = 0.001; 
                }
            } else if (state.animPhase === 'CONVERGE') {
                state.lerpSpeed *= 1.05; 
                if (state.lerpSpeed > 0.3) {
                    state.lerpSpeed = 0.3; 
                    state.animPhase = 'IDLE'; 
                }
            } else {
                state.lerpSpeed = 2.0 * dt; 
            }

            const isTree = state.mode === 'TREE';
            const isHeart = state.mode === 'HEART';

            if(isTree || isHeart) {
                state.rotVelocity = 0;
                const spd = 0.2 * dt;
                meshSphere.rotation.y += spd; meshBox.rotation.y += spd; meshTetra.rotation.y += spd;
                photoGroup.rotation.y += spd;
            } else {
                state.rotVelocity *= 0.95; 
                if(state.rotVelocity > 1.5) state.rotVelocity = 1.5;
                if(state.rotVelocity < -1.5) state.rotVelocity = -1.5;
                const spd = (0.02 + state.rotVelocity) * dt;
                meshSphere.rotation.y += spd; meshBox.rotation.y += spd; meshTetra.rotation.y += spd;
                photoGroup.rotation.y = meshSphere.rotation.y;
            }

            star.rotation.y = time;
            const starY = isTree ? CONFIG.treeHeight + 1.5 : 0;
            star.position.lerp(vTmp.set(0, starY, 0), 0.1);
            star.scale.setScalar(THREE.MathUtils.lerp(star.scale.x, isTree?1.0:0.6, 0.1));

            for(let i=0; i<CONFIG.count; i++) {
                const p = particleData[i];
                let target;

                if (state.animPhase === 'EXPLODE') {
                    target = p.tExplode;
                    p.currentPos.lerp(target, 0.1);
                } else {
                    if (isHeart) target = p.tHeart;
                    else target = isTree ? p.tTree : p.tScatter;
                    
                    if (isTree && p.isFloor) {
                        const lag = time * 0.1 * (p.floorRadius / CONFIG.floorRadius); 
                        const angle = p.floorAngle - lag; 
                        const wave = Math.sin(p.floorRadius * 0.5 - time * 2.0) * 1.5;
                        p.tTree.set(p.floorRadius * Math.cos(angle), wave, p.floorRadius * Math.sin(angle));
                        target = p.tTree;
                    }
                    
                    p.currentPos.lerp(target, state.lerpSpeed);
                }

                const blink = Math.sin(time * p.speed + p.offset);
                const intensity = Math.pow(0.5 * blink + 0.5, 3.0); 
                const scale = p.baseScale * (0.3 + 1.2 * intensity); 

                dummy.position.copy(p.currentPos);
                dummy.scale.setScalar(scale);
                if (!isTree && i < CONFIG.textCount) dummy.rotation.set(0, 0, 0); 
                else dummy.rotation.set(time + p.offset, time * 0.5, 0);
                dummy.updateMatrix();

                if (p.meshIndex === 0) meshSphere.setMatrixAt(p.internalIndex, dummy.matrix);
                else if (p.meshIndex === 1) meshBox.setMatrixAt(p.internalIndex, dummy.matrix);
                else meshTetra.setMatrixAt(p.internalIndex, dummy.matrix);
            }
            meshSphere.instanceMatrix.needsUpdate = true;
            meshBox.instanceMatrix.needsUpdate = true;
            meshTetra.instanceMatrix.needsUpdate = true;

            const hudWorldPos = hudPosition.clone().applyMatrix4(camera.matrixWorld);
            photos.forEach(p => {
                if (state.animPhase === 'EXPLODE') {
                    // 修复：让照片真正飞出去
                    p.position.lerp(p.userData.explodePos, 0.08); 
                    p.rotation.x += 0.1;
                    p.rotation.y += 0.1;
                } else {
                    if(p === state.activePhoto && state.mode === 'SCATTER') {
                        controls.enabled = false;
                        const localTarget = photoGroup.worldToLocal(hudWorldPos.clone());
                        localTarget.y += Math.sin(time * 2.0) * 0.5;
                        p.position.lerp(localTarget, 0.1);
                        p.lookAt(camera.position);
                        p.scale.lerp(vTmp.set(3.5, 3.5, 3.5), 0.1); 
                        p.renderOrder = 9999; p.material.depthTest = false; 
                    } else {
                        if(!state.activePhoto) controls.enabled = true;
                        p.renderOrder = 0; p.material.depthTest = true;
                        p.scale.lerp(vTmp.set(1,1,1), 0.1);
                        
                        if(isHeart) {
                            const t = p.userData.heartPos;
                            p.position.lerp(t, state.lerpSpeed);
                            p.lookAt(0, 45, 0); 
                        }
                        else if(isTree) {
                            let t = p.userData.treePos;
                            p.position.lerp(t, state.lerpSpeed);
                            p.rotation.x = p.userData.treeRot.x + Math.sin(time*2)*0.1;
                            p.rotation.y = p.userData.treeRot.y + Math.cos(time*1.5)*0.1;
                            p.rotation.z = p.userData.treeRot.z;
                        } else {
                            const r = p.userData.scatterRadius;
                            const a = p.userData.scatterAngle;
                            p.position.lerp(vTmp.set(r*Math.cos(a), p.userData.scatterY + Math.sin(time+p.id)*2, r*Math.sin(a)), state.lerpSpeed);
                            p.rotation.y += p.userData.selfRotSpeed;
                            p.rotation.x += p.userData.selfRotSpeed * 0.5;
                        }
                    }
                }
            });

            controls.update();

            // --- SELECTIVE BLOOM RENDER ---
            scene.traverse(darkenNonBloomed);
            bloomComposer.render();
            scene.traverse(restoreMaterial);
            mixPass.uniforms.bloomTexture.value = bloomComposer.renderTarget2.texture;
            finalComposer.render();
        }

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); 
            bloomComposer.setSize(window.innerWidth, window.innerHeight);
            finalComposer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- KEYBOARD CONTROLS ---
        window.addEventListener('keydown', (e) => {
            if (e.key === '1') {
                state.targetMode = 'TREE';
                state.activePhoto = null; 
            }
            if (e.key === '2') {
                state.targetMode = 'SCATTER';
                state.activePhoto = null; 
            }
            if (e.key === '3') {
                state.targetMode = 'SCATTER'; 
                if (!state.activePhoto && photos.length > 0) {
                    findNearestPhoto();
                    if(!state.activePhoto) state.activePhoto = photos[0];
                }
            }
            if (e.key === '4') {
                if (state.targetMode !== 'SCATTER') state.targetMode = 'SCATTER';
                state.rotVelocity += 0.8; 
            }
            if (e.key === '5') {
                state.targetMode = 'HEART';
                state.activePhoto = null;
            }
            if (e.key === '6') {
                if (state.targetMode !== 'SCATTER') state.targetMode = 'SCATTER';
                state.rotVelocity -= 0.8; 
            }
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                if (photos.length === 0) return;
                if (state.targetMode !== 'SCATTER') state.targetMode = 'SCATTER';
                let index = state.activePhoto ? photos.indexOf(state.activePhoto) : 0;
                if (e.key === 'ArrowRight') index++;
                else index--;
                if (index >= photos.length) index = 0;
                if (index < 0) index = photos.length - 1;
                state.activePhoto = photos[index];
            }
            if (e.key.toLowerCase() === 'h') {
                const ui = document.getElementById('ui-layer');
                const hand = document.getElementById('hand-interface');
                const status = document.getElementById('status-text');
                const isHidden = ui.style.display === 'none';
                const newVal = isHidden ? 'block' : 'none'; 
                ui.style.display = isHidden ? 'flex' : 'none';
                hand.style.display = newVal;
                status.style.display = newVal;
            }
        });

        initAI();
        animate();
    </script>
</body>
</html>