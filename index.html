<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Merry Christmas - 3D Replica</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Arial', sans-serif;
            font-size: 24px;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="info">Merry Christmas ğŸ„</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // 1. åˆå§‹åŒ–åœºæ™¯ã€ç›¸æœºå’Œæ¸²æŸ“å™¨
        const scene = new THREE.Scene();
        // æ·»åŠ è¿·é›¾æ•ˆæœï¼Œè®©èƒŒæ™¯æ›´æŸ”å’Œ
        scene.fog = new THREE.FogExp2(0x050510, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        camera.position.y = 1;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // 2. åˆ›å»ºåœ£è¯æ ‘å‡½æ•°
        function createTree() {
            const treeGroup = new THREE.Group();

            // æ ‘å¶æè´¨
            const leafMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ff44, 
                roughness: 0.8,
                flatShading: true 
            });

            // æ ‘å¹²æè´¨
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });

            // åˆ›å»ºä¸‰å±‚æ ‘å¶
            const levels = 4;
            for(let i=0; i<levels; i++) {
                const size = 1.5 - (i * 0.3);
                const height = 1;
                const geometry = new THREE.ConeGeometry(size, height, 8);
                const cone = new THREE.Mesh(geometry, leafMaterial);
                cone.position.y = (i * 0.8) + 0.5;
                treeGroup.add(cone);
            }

            // æ ‘å¹²
            const trunkGeo = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
            const trunk = new THREE.Mesh(trunkGeo, trunkMaterial);
            trunk.position.y = 0;
            treeGroup.add(trunk);

            // æ ‘é¡¶æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.OctahedronGeometry(0.15);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.y = levels * 0.8 + 0.2;
            treeGroup.add(star);

            // ç®€å•çš„è£…é¥°çƒ
            const ornamentColors = [0xff0000, 0x0000ff, 0xffd700, 0xff00ff];
            for(let i=0; i<15; i++) {
                const color = ornamentColors[Math.floor(Math.random() * ornamentColors.length)];
                const orbGeo = new THREE.SphereGeometry(0.08, 8, 8);
                const orbMat = new THREE.MeshStandardMaterial({ color: color });
                const orb = new THREE.Mesh(orbGeo, orbMat);
                
                // éšæœºä½ç½®ï¼ˆç®€å•ä¼°ç®—åœ¨åœ†é”¥è¡¨é¢é™„è¿‘ï¼‰
                const theta = Math.random() * Math.PI * 2;
                const yHeight = Math.random() * 2.5 + 0.5; // é«˜åº¦ 0.5 åˆ° 3.0
                const radius = (3.5 - yHeight) * 0.35; // è¶Šå¾€ä¸ŠåŠå¾„è¶Šå°
                
                orb.position.set(
                    Math.cos(theta) * radius,
                    yHeight,
                    Math.sin(theta) * radius
                );
                treeGroup.add(orb);
            }

            return treeGroup;
        }

        const christmasTree = createTree();
        christmasTree.position.y = -1.5;
        scene.add(christmasTree);

        // 3. åˆ›å»ºé›ªèŠ±ç²’å­ç³»ç»Ÿ
        const particleCount = 1500;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleVelocities = [];

        for(let i=0; i<particleCount; i++) {
            particlePositions[i*3] = (Math.random() - 0.5) * 20;     // x
            particlePositions[i*3+1] = (Math.random() - 0.5) * 20;   // y
            particlePositions[i*3+2] = (Math.random() - 0.5) * 20;   // z
            
            particleVelocities.push({
                y: -Math.random() * 0.05 - 0.02, // ä¸‹è½é€Ÿåº¦
                x: (Math.random() - 0.5) * 0.02, // æ¨ªå‘é£˜åŠ¨
                z: (Math.random() - 0.5) * 0.02
            });
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        const particleMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.05,
            transparent: true,
            opacity: 0.8
        });
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        // 4. ç¯å…‰è®¾ç½®
        const ambientLight = new THREE.AmbientLight(0x404040, 2); // ç¯å¢ƒå…‰
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffaa00, 1, 10);
        pointLight.position.set(2, 2, 2);
        scene.add(pointLight);

        const blueLight = new THREE.PointLight(0x0044ff, 1, 10);
        blueLight.position.set(-2, 1, 2);
        scene.add(blueLight);

        // 5. åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            // æ—‹è½¬åœ£è¯æ ‘
            christmasTree.rotation.y += 0.005;

            // æ›´æ–°é›ªèŠ±ä½ç½®
            const positions = particles.geometry.attributes.position.array;
            for(let i=0; i<particleCount; i++) {
                positions[i*3] += particleVelocities[i].x;
                positions[i*3+1] += particleVelocities[i].y;
                positions[i*3+2] += particleVelocities[i].z;

                // å¦‚æœé›ªèŠ±è½åˆ°åº•éƒ¨ï¼Œé‡ç½®åˆ°é¡¶éƒ¨
                if(positions[i*3+1] < -5) {
                    positions[i*3+1] = 5;
                    positions[i*3] = (Math.random() - 0.5) * 20;
                    positions[i*3+2] = (Math.random() - 0.5) * 20;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // ç®€å•äº¤äº’ï¼šè®©æ ‘éšé¼ æ ‡å¾®åŠ¨ (å¯é€‰ä¼˜åŒ–)
            
            renderer.render(scene, camera);
        }

        // 6. çª—å£å¤§å°è°ƒæ•´å¤„ç†
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // é¼ æ ‡ç§»åŠ¨äº¤äº’
        document.addEventListener('mousemove', (event) => {
            const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // å¾®å¾®ç§»åŠ¨ç›¸æœº
            camera.position.x += (mouseX - camera.position.x) * 0.05;
            camera.position.y += (mouseY + 1 - camera.position.y) * 0.05;
            camera.lookAt(0, 0, 0);
        });

        animate();
    </script>
</body>
</html>
